package main

import (
	"encoding/json"
	"html/template"
	"io"
	"os"
	"path/filepath"
	"strings"
)

func baseTemplate() string {
	return `package {{.Package}}

// This code generated by go generate.
// DO NOT EDIT BY HAND!

{{- $lang := .Lang}}
{{- $fields := .Fields}}

type {{.Name}} interface {
{{- range $jsonName, $val := .Fields}}
{{- if not (StartsWith $jsonName "@")}}
	{{- with (GetDefinition $fields $jsonName) }}
		{{- if .Description}}
	// {{.Description}}
	//
	// In {{$lang}}, this message translates to: {{$val}}
		{{- else}}
	// No description provided for @{{$jsonName}}
	//
	// In {{$lang}}, this message translates to: {{$val}}
		{{- end}}
		{{- with .Placeholders}}
	{{(Title $jsonName)}}({{(PlaceholderTypes .)}}) string
		{{- else}}
	{{(Title $jsonName)}}() string
		{{- end}}
	{{- else}}
	// No definition provided for @{{$jsonName}}
	//
	// In {{$lang}}, this message translates to: {{$val}}
	{{(Title $jsonName)}}() string
	{{- end}}
{{- end}}
{{- end }}
}

// Load loads the translation for the given language.
// Defaults to base language if not found.
func Load(lang string) {{.Name}} {
	switch lang {
	{{- range $lang := .Langs}}
	case "{{$lang}}":
		return &Translation{{(Title (CamelCase $lang))}}{}
	{{- end}}
	}
	return &Translation{{(Title (CamelCase .Lang))}}{}
}
`
}

func generateBase(config Config, langs []string) error {
	baseLang := strings.Split(filepath.Base(config.Base), ".")[0]

	in, err := os.Open(config.Base)
	if err != nil {
		return err
	}
	defer in.Close()

	b, err := io.ReadAll(in)
	if err != nil {
		return err
	}

	var resp map[string]interface{}
	err = json.Unmarshal(b, &resp)
	if err != nil {
		return err
	}

	data := struct {
		Name    string
		Lang    string
		Langs   []string
		Fields  map[string]interface{}
		Package string
	}{
		"Base",
		baseLang,
		langs,
		resp,
		config.Exec.Package,
	}

	tpl, err := template.New("base.tpl").Funcs(templateFns()).Parse(baseTemplate())
	if err != nil {
		return err
	}

	err = os.MkdirAll(config.Exec.Path, 0755)
	if err != nil {
		return err
	}

	out, err := os.Create(filepath.Join(config.Exec.Path, "/base.go"))
	if err != nil {
		return err
	}
	defer out.Close()

	err = tpl.Execute(out, data)
	if err != nil {
		return err
	}

	return nil
}
